Manipulating
User-Controlled
Variables
This
attack
targets
user
controlled
variables
(
DEBUG=1
,
PHP
Globals
,
and
So
Forth
)
.
An
attacker
can
override
environment
variables
leveraging
user-supplied
,
untrusted
query
variables
directly
used
on
the
application
server
without
any
data
sanitization
.
In
extreme
cases
,
the
attacker
can
change
variables
controlling
the
business
logic
of
the
application
.
For
instance
,
in
languages
like
PHP
,
a
number
of
poorly
set
default
configurations
may
allow
the
user
to
override
variables
.
A
variable
consumed
by
the
application
server
is
exposed
to
the
client
.
A
variable
consumed
by
the
application
server
can
be
overwritten
by
the
user
.
The
application
server
trusts
user
supplied
data
to
compute
business
logic
.
The
application
server
does
not
perform
proper
input
validation
.
If
the
register_globals
option
is
enabled
,
PHP
will
create
global
variables
for
each
GET
,
POST
,
and
cookie
variable
included
in
the
HTTP
request
.
This
means
that
a
malicious
user
may
be
able
to
set
variables
unexpectedly
.
For
instance
make
sure
that
the
server
setting
for
PHP
does
not
expose
global
variables
.
A
software
system
should
be
reluctant
to
trust
variables
that
have
been
initialized
outside
of
its
trust
boundary
.
Ensure
adequate
checking
is
performed
when
relying
on
input
from
outside
a
trust
boundary
.
Separate
the
presentation
layer
and
the
business
logic
layer
.
Variables
at
the
business
logic
layer
should
not
be
exposed
at
the
presentation
layer
.
This
is
to
prevent
computation
of
business
logic
from
user
controlled
input
data
.
Use
encapsulation
when
declaring
your
variables
.
This
is
to
lower
the
exposure
of
your
variables
.
Assume
all
input
is
malicious
.
Create
a
white
list
that
defines
all
valid
input
to
the
software
system
based
on
the
requirements
specifications
.
Input
that
does
not
match
against
the
white
list
should
be
rejected
by
the
program
.
